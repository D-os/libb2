/*
 * Copyright (c) 2005 Palmsource, Inc.
 *
 * This software is licensed as described in the file LICENSE, which
 * you should have received as part of this distribution. The terms
 * are also available at http://www.openbinder.org/license.html.
 *
 * This software consists of voluntary contributions made by many
 * individuals. For the exact contribution history, see the revision
 * history and logs, available at http://www.openbinder.org
 */

#ifndef _STORAGE_DATUMGENERATORINT_H
#define _STORAGE_DATUMGENERATORINT_H

/*!	@file storage/DatumGeneratorInt.h
	@ingroup CoreSupportDataModel
	@brief Utility class for dynamically generating datums associated with integer keys.
*/

#include <storage/StreamDatum.h>

#include <support/KeyedVector.h>

#if _SUPPORTS_NAMESPACE
namespace os {
namespace storage {
#endif

/*!	@addtogroup CoreSupportDataModel
	@{
*/

// ==========================================================================
// ==========================================================================

//!	Utility class for dynamically generating datums associated with integer keys.
/*!	This class provides standard tools for generating IDatum objects on-demand
	that are bound to an integer-based key.  It is used when you have data in
	an indexed vector or structure which is normally stored in its raw form,
	and need to generate datum objects for its individual pieces of data for
	integration with the general data model.

	Note that because the cached datums generated by this class do not own
	their data, when an item is removed from the SDatumGeneratorInt a
	cached datum will loose its associated data.  In this case the datum
	silently becomes B_UNDEFINED_VALUE and modifications to it are no longer
	allowed.

	@todo May want to revisit deletion, the value that gets set and if any
	events get pushed when it happens.

	@nosubgrouping
*/
class SDatumGeneratorInt : public virtual SAtom
{
public:
	// --------------------------------------------------------------
	/*!	@name Bookkeeping
		Creation, destruction, locking, etc. */
	//@{
									SDatumGeneratorInt(uint32_t mode = IDatum::READ_WRITE);
									SDatumGeneratorInt(const SContext& context, uint32_t mode = IDatum::READ_WRITE);
protected:
	virtual							~SDatumGeneratorInt();
public:

		//!	Lock the datum's state.
		/*!	To keep itself consistent, this class provides a public lock that
			is used when doing read/write operations on the class state as well
			as the actual data.  The default implemention of this method acquires
			an internal lock.  You can override it to cause all internal
			implementation to acquire some other lock.  Be sure to also override
			Unlock() if doing so. */
	virtual	lock_status_t			Lock() const;

		//!	Unlock the datum's state.
	virtual	void					Unlock() const;

	//@}

	//  ------------------------------------------------------------------
	/*!	@name Index Management
		Manage the mapping of indices to datums. */
	//@{

			//!	Retrieve a datum of a given index.
			/*!	Returns an existing datum if one is currently active for the index.
				Otherwise, calls NewDatumLocked() to create a new datum and associates
				it with this index. */
			sptr<IDatum>			DatumAtLocked(size_t index);

			//!	Adjust all active datums due to items being added/removed from the generator.
			/*!	Your subclass must call this when it changes its set of datum items. */
			void					UpdateDatumIndicesLocked(size_t index, ssize_t delta);

	//@}

	//  ------------------------------------------------------------------
	/*!	@name Value-based Structure Access
		These are like the corresponding virtuals on BStreamDatum. */
	//@{

			//!	Convenience function for changing a value.
			/*!	The implementation takes care of calling ReportChangeAtLocked()
				for you if the value has changed.  This is semantically the same
				as BStreamDatum::SetValue(). */
			void					SetValueAtLocked(size_t index, const SValue& value);

			//!	The default implementation returns ValueAtLocked().Type().
	virtual	uint32_t				ValueTypeAtLocked(size_t index) const;
			//!	The default implementation uses ValueAtLocked() and StoreValueAtLocked() to change the type.
	virtual	status_t				StoreValueTypeAtLocked(size_t index, uint32_t type);
			//!	The default implementation returns ValueAtLocked().Length().
	virtual	off_t					SizeAtLocked(size_t index) const;
			//!	The default implementation uses ValueAtLocked() and StoreValueAtLocked() to change the size.
	virtual	status_t				StoreSizeAtLocked(size_t index, off_t size);
			//!	Must be implemented by subclasses to return the current value at an index.
	virtual	SValue					ValueAtLocked(size_t index) const = 0;
			//!	Must be implemented by subclasses change the current value at an index.
	virtual	status_t				StoreValueAtLocked(size_t index, const SValue& value) = 0;

			//!	Similar to BStreamDatum::ReportChangeLocked(), using same change flags.
	virtual	void					ReportChangeAtLocked(size_t index, const sptr<IBinder>& editor, uint32_t changes, off_t start=-1, off_t length=-1);

	//@}

	//  ------------------------------------------------------------------
	/*!	@name Stream Virtuals
		These are like the corresponding virtuals on BStreamDatum. */
	//@{

			//!	The default implementation return uses ValueAtLocked() to retrieve the data.
	virtual	const void*				StartReadingAtLocked(	size_t index, off_t position,
															ssize_t* inoutSize, uint32_t flags) const;
			//!	The default implementation does nothing.
	virtual	void					FinishReadingAtLocked(	size_t index, const void* data) const;
			//!	The default implementation uses ValueAtLocked() to create a temporary buffer.
	virtual	void*					StartWritingAtLocked(	size_t index, off_t position,
															ssize_t* inoutSize, uint32_t flags);
			//!	The default implementation uses StoreValueAtLocked() to write the data.
	virtual	void					FinishWritingAtLocked(	size_t index, void* data);

	//@}

	//  ------------------------------------------------------------------
	/*!	@name Datum Generation */
	//@{

	class IndexedDatum;

			//!	Called when a new datum object needs to be created.
			/*!	The default implementation instantiates and returns a
				new IndexedDatum object. */
	virtual	sptr<IndexedDatum>		NewDatumLocked(size_t index, uint32_t mode);

	//@}

private:
									SDatumGeneratorInt(const SDatumGeneratorInt&);
			SDatumGeneratorInt&	operator=(const SDatumGeneratorInt&);

	friend class IndexedDatum;

	const	SContext				m_context;
	const	uint32_t				m_mode;

	mutable	SLocker					m_lock;
			SKeyedVector<size_t, wptr<IndexedDatum> >*	m_datums;
	mutable	SValue					m_tmpValue;
			size_t					m_writeLen;
};

// --------------------------------------------------------------------------

//!	Datum object generated for an item in SDatumGeneratorInt.
/*!
	@nosubgrouping
*/
class SDatumGeneratorInt::IndexedDatum : public BStreamDatum
{
	// --------------------------------------------------------------
	/*!	@name Bookkeeping
		Creation, destruction, locking, etc. */
	//@{
public:
									IndexedDatum(const SContext& context, const sptr<SDatumGeneratorInt>& owner, size_t index, uint32_t mode);
protected:
	virtual							~IndexedDatum();
			//!	The destructor must call Lock(), so return FINISH_ATOM_ASYNC to avoid deadlocks.
	virtual	status_t				FinishAtom(const void* id);
			//!	Make this object stay around while there are links on it.
	virtual	bool					HoldRefForLink(const SValue& binding, uint32_t flags);
public:

			//!	Reimplemented to use the BIndexedDatumGenerator lock.
	virtual	lock_status_t			Lock() const;
			//!	Reimplemented to use the BIndexedDatumGenerator lock.
	virtual	void					Unlock() const;

	//@}

	// --------------------------------------------------------------
	/*!	@name BStreamDatum Implementation
		Redirect high-level datum operations back up to BIndexedDatumGenerator. */
	//@{

	virtual	uint32_t				ValueTypeLocked() const;
	virtual	status_t				StoreValueTypeLocked(uint32_t type);
	virtual	off_t					SizeLocked() const;
	virtual	status_t				StoreSizeLocked(off_t size);
	virtual	SValue					ValueLocked() const;
	virtual	status_t				StoreValueLocked(const SValue& value);
	virtual	void					ReportChangeLocked(const sptr<IBinder>& editor, uint32_t changes, off_t start=-1, off_t length=-1);
	virtual	const void*				StartReadingLocked(	const sptr<Stream>& stream, off_t position,
														ssize_t* inoutSize, uint32_t flags) const;
	virtual	void					FinishReadingLocked(const sptr<Stream>& stream, const void* data) const;
	virtual	void*					StartWritingLocked(	const sptr<Stream>& stream, off_t position,
														ssize_t* inoutSize, uint32_t flags);
	virtual	void					FinishWritingLocked(const sptr<Stream>& stream, void* data);

			const sptr<SDatumGeneratorInt>	m_owner;
			ssize_t					m_index;
};

// ==========================================================================
// ==========================================================================

/*!	@} */

#if _SUPPORTS_NAMESPACE
} } // namespace os::storage
#endif

#endif // _STORAGE_DATUMGENERATORINT_H
