/*
 * Copyright (c) 2005 Palmsource, Inc.
 * 
 * This software is licensed as described in the file LICENSE, which
 * you should have received as part of this distribution. The terms
 * are also available at http://www.openbinder.org/license.html.
 * 
 * This software consists of voluntary contributions made by many
 * individuals. For the exact contribution history, see the revision
 * history and logs, available at http://www.openbinder.org
 */

#ifndef _VNODE_H_
#define _VNODE_H_

#include <posix/sys/types.h>
#include <posix/sys/uio.h>
#include <posix/sys/queue.h>


#ifdef __cplusplus
extern "C" {
#endif 
 
typedef uint32_t inode_t; // inode number
typedef int32_t  lbno_t;  // logical block number in a file, may be negative for indirect blocks 
typedef int32_t  bno_t;   // physical block number on disk/media 
typedef uint16_t segno_t; // segment number

/*
 * Structure used to pass around logical block paths generated by
 * ufs_getlbns and used by truncate and bmap code.
 */
struct indir {
	bno_t in_lbn;		/* Logical block number. */
	int	in_off;			/* Offset in buffer. */
	int	in_exists;		/* Flag if the block exists. */
};

struct componentname;
typedef int32_t doff_t;

/*
 * This is defined here rather than in BufferCache.h so that the
 * forward references will resolve without forcing code that references vnodes
 * but not the buffer cache to have to include BufferCache.h
 */
typedef struct BufferCacheEntryType {
	TAILQ_ENTRY(BufferCacheEntryType) b_freelist;  // link entry onto some list
													// may or may not be free list
	int 		b_freelistindex;  // Free list index. which queue buffer is on, if any
	struct VnodeType *b_vnode;  // associated vnode
	lbno_t     b_lbn;  // logical block number within the file
	bno_t      b_bno;  // physical block number being buffered
	void      *b_data;
	volatile uint32_t   b_flags;
	status_t   b_lastOpStatus;
	LIST_ENTRY(BufferCacheEntryType) b_vnodeLink; // entry is on a vnode's clean or dirty list
} BufferCacheEntryType;

// Free bufCache queues.  Newest entries added to the end so that head has
// the oldest entries and is first to be replaced.
// We use three queues like BSD:
// BQ_LOCKED - buffers that are locked and cannot be replaced
// BQ_LRU - LRU for regular buffers
// BQ_AGE - LRU for unproven buffers, buffers which haven't proved to be useful
//          or are known to be invalid.
//          this queue is emptied before the LRU queue is used.
// BQ_SHARED - valid buffers that are shared with the client.
//             these buffers cannot be replaced
#define NUM_BQUEUES 4
#define BQ_LOCKED   0
#define BQ_LRU      1
#define BQ_AGE      2
#define BQ_SHARED   3

#define B_DATASIZE 	4096		// regular data size is 4KB
#define B_DATASIZE_512 	512		// fs meta-data size uses 512 bytes
/*
 * These flags are kept in b_flags.
 */
#define	B_AGE		0x00000001	/* Move to age queue when I/O done. */
#define	B_ASYNC		0x00000004	/* Start I/O, do not wait. */
#define	B_BAD		0x00000008	/* Bad block revectoring in progress. */
#define	B_BUSY		0x00000010	/* I/O in progress. */
#define	B_SCANNED	0x00000020	/* Block already pushed during sync */
#define	B_CALL		0x00000040	/* Call b_iodone from biodone. */
#define	B_DELWRI	0x00000080	/* Delay I/O until buffer reused. */
#define	B_DIRTY		0x00000100	/* Dirty page to be pushed out async. */
#define	B_DONE		0x00000200	/* I/O completed. */
#define	B_EINTR		0x00000400	/* I/O was interrupted */
#define	B_ERROR		0x00000800	/* I/O error occurred. */
#define	B_GATHERED	0x00001000	/* LFS: already in a segment. */
#define	B_INVAL		0x00002000	/* Does not contain valid info. */
#define	B_LOCKED	0x00004000	/* Locked in core (not reusable). */
#define	B_NOCACHE	0x00008000	/* Do not cache block after use. */
#define	B_CACHE		0x00020000	/* Bread found us in the cache. */
#define	B_PHYS		0x00040000	/* I/O to user memory. */
#define	B_RAW		0x00080000	/* Set by physio for raw transfers. */
#define	B_READ		0x00100000	/* Read buffer. */
#define	B_TAPE		0x00200000	/* Magnetic tape I/O. */
#define	B_WANTED	0x00800000	/* Process wants this buffer. */
#define	B_WRITE		0x01000000	/* Write buffer (pseudo flag). */
#define	B_DATA_512	0x02000000	/* data size is 512 bytes instead of regular 4KB */
#define	B_VFLUSH	0x04000000	/* Buffer is being synced. */

#define	B_PAGE_SHARED	0x08000000
#define	B_PAGE_WRITE	0x10000000	/* */
#define	B_DEFER_READ	0x20000000
#define	B_BNO_VALID		0x40000000
#define	B_PAGE_LOCKED	0x80000000



typedef status_t op_read_vnode(void *mount, inode_t vnid, char r, struct VnodeType **node);
typedef status_t op_write_vnode(struct VnodeType *vnodeP, char flags);
typedef status_t op_remove_vnode(struct VnodeType *vnodeP, char r);
typedef status_t op_secure_vnode(struct VnodeType *vnodeP);

typedef status_t op_allocate_vnode(struct VnodeType *parentVnodeP, struct VnodeType **resultVnodePP);
typedef status_t op_lookup(struct VnodeType *dirVnodeP, struct VnodeType **resultVnodePP, struct componentname *cnp);

typedef status_t op_check_access(struct VnodeType *vnodeP, int mode, uint32_t callerUID);

typedef status_t op_create(struct VnodeType *parentVnodeP, struct VnodeType **resultVnodePP, struct componentname *cnp);
typedef status_t op_mkdir(struct VnodeType *parentDirVnodeP, struct VnodeType **newDirVnodePP, struct componentname *cnp);
typedef status_t op_symlink(void *dir, const char *name, const char *path);
typedef status_t op_link(void *dir, const char *name, struct VnodeType *vnodeP);

typedef status_t op_rename(struct VnodeType *oldDirVnodeP, struct VnodeType *oldVnodeP, struct componentname *oldcnp,
						   struct VnodeType *newDirVnodeP, struct VnodeType *newVnodeP, struct componentname *newcnp);
typedef status_t op_unlink(struct VnodeType *parentDirVnodeP, struct VnodeType *vnodeP, struct componentname *cnp);

typedef status_t op_rmdir(struct VnodeType *parentDirVnodeP, struct VnodeType *vnodeP, struct componentname *cnp);

typedef status_t op_readlink(struct VnodeType *vnodeP, char *buf, size_t *bufsize);

typedef status_t op_opendir(struct VnodeType *vnodeP, void **cookie);
typedef status_t op_closedir(struct VnodeType *vnodeP, void *cookie);
typedef status_t op_rewinddir(struct VnodeType *vnodeP, void *cookie);
struct DirEntry;
typedef status_t op_readdir(struct VnodeType *vnodeP, void *cookie, long *num, struct DirEntry *buf, size_t bufsize);
typedef status_t op_getbufferforoffset(struct VnodeType *vnodeP, off_t offset, BufferCacheEntryType **bufCachePP);
typedef status_t op_bufferallocate(struct VnodeType *vnodeP, off_t offset, int32_t size, uint32_t flags, BufferCacheEntryType **bufCachePP);
typedef status_t op_getphysicalblockaddr(struct VnodeType *vnodeP, lbno_t logicalBlockNum, bno_t *physicalBlockNumP, int *numP);

typedef status_t op_open(struct VnodeType *vnodeP, int omode);
typedef status_t op_close(struct VnodeType *vnodeP, void *cookie);
typedef status_t op_free_cookie(struct VnodeType *vnodeP, void *cookie);
typedef status_t op_read(struct VnodeType *vnodeP, off_t pos, uint8_t *buf, size_t *len);
typedef status_t op_write(struct VnodeType *vnodeP, off_t pos, const uint8_t *buf, size_t *len);
typedef status_t op_readv(struct VnodeType *vnodeP, void *cookie, off_t pos, const struct iovec *vec,
						  size_t count, size_t *len);
typedef status_t op_writev(struct VnodeType *vnodeP, void *cookie, off_t pos, const struct iovec *vec,
						   size_t count, size_t *len);
typedef status_t op_readbuffers(struct VnodeType *vnode, size_t count, BufferCacheEntryType **bufCacheP);
typedef status_t op_writebuffers(struct VnodeType *vnode, size_t count, BufferCacheEntryType **bufCacheP);

typedef status_t op_ioctl(struct VnodeType *vnodeP, void *cookie, int cmd, void *buf, size_t len);

typedef status_t op_truncate(struct VnodeType *vnodeP, off_t endOffset, uint32_t flags);
typedef status_t op_setflags(struct VnodeType *vnodeP, void *cookie, int flags);

// used primarily to update time stamp and flags, with an option to
// flush the changes to disk and to wait for the flush to complete
typedef status_t op_update(struct VnodeType *vnodeP, time_t accessTime, time_t modifyTime, int flags);

typedef status_t op_rstat(struct VnodeType *vnodeP, struct stat *);
typedef status_t op_wstat(struct VnodeType *vnodeP, struct stat *, long mask);
typedef status_t op_fsync(struct VnodeType *vnodeP);

typedef status_t op_initialize(const char *devname, void *parms, size_t len);
typedef status_t op_reclaim(struct VnodeType *vnodeP);
typedef status_t op_mount(int /*nspace_id*/ nsid, const char *devname, ulong flags,
						  void *parms, size_t len, void **data, inode_t *vnid);
typedef status_t op_unmount(struct VnodeType *vnodeP);
typedef status_t op_sync(struct VnodeType *vnodeP);
struct fs_info;
typedef status_t op_rfsstat(struct VnodeType *vnodeP, struct fs_info *);
typedef status_t op_wfsstat(struct VnodeType *vnodeP, struct fs_info *, long mask);

typedef status_t op_write_attr(struct VnodeType *vnodeP, const char *name, int type,
							   const void *buf, size_t *len, off_t pos);
typedef status_t op_read_attr(struct VnodeType *vnodeP, const char *name, int type,
							  void *buf, size_t *len, off_t pos);

typedef void op_wake_vnode(struct VnodeType *vnodeP, void *cookie, uint pmcookietype);
typedef void op_suspend_vnode(struct VnodeType *vnodeP, void *cookie, uint pmcookietype);

typedef struct vnode_ops {
	op_read_vnode			(*read_vnode);
	op_write_vnode			(*write_vnode);
	op_remove_vnode			(*remove_vnode);
	op_secure_vnode			(*secure_vnode);
	op_allocate_vnode       (*allocate_vnode);
	op_lookup				(*lookup);
	op_check_access			(*check_access);
	op_create				(*create);
	op_mkdir				(*mkdir);
	op_symlink				(*symlink);
	op_link					(*link);
	op_rename				(*rename);
	op_unlink				(*unlink);
	op_rmdir				(*rmdir);
	op_readlink				(*readlink);
	op_opendir				(*opendir);
	op_closedir				(*closedir);
	op_rewinddir			(*rewinddir);
	op_readdir				(*readdir);
	op_getbufferforoffset   (*getbufferforoffset);
	op_bufferallocate       (*bufferallocate);
	op_getphysicalblockaddr (*getphysicalblockaddr);
	op_open					(*open);
	op_close				(*close);
	op_read					(*read);
	op_write				(*write);
	op_readv				(*readv);
	op_writev				(*writev);
	op_readbuffers			(*readbuffers);
	op_writebuffers			(*writebuffers);
	op_ioctl				(*ioctl);
	op_truncate             (*truncate);
	op_setflags				(*setflags);
	op_update				(*update);
	op_rstat				(*rstat);
	op_wstat				(*wstat);
	op_fsync				(*fsync);
	op_initialize			(*initialize);
	op_reclaim				(*reclaim);
	op_mount				(*mount);
	op_unmount				(*unmount);
	op_sync					(*sync);
	op_rfsstat				(*rfsstat);
	op_wfsstat				(*wfsstat);
	op_write_attr			(*write_attr);
	op_read_attr			(*read_attr);
	op_wake_vnode			(*wake_vnode);
	op_suspend_vnode		(*suspend_vnode);
} vnode_ops;


/*
 * Vnode types.  VNON means no type.
 */
enum vtype	{ VNON, VREG, VDIR, VBLK, VCHR, VLNK, VSOCK, VFIFO, VBAD };

/*
 * Vnode tag types.
 * These are for the benefit of external programs only (e.g., pstat)
 * and should NEVER be inspected by the kernel.
 */
enum vtagtype	{
	VT_NON, VT_UFS, VT_NFS, VT_MFS, VT_MSDOSFS, VT_LFS, VT_LOFS, VT_FDESC,
	VT_PORTAL, VT_NULL, VT_UMAP, VT_KERNFS, VT_PROCFS, VT_AFS, VT_ISOFS,
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_CODA, VT_FILECORE, VT_NTFS, VT_VFS,
	VT_OVERLAY, VT_SMBFS, VT_PTYFS
};

/*
 * Vnode flags.
 */
#define	VROOT		0x0001	/* root of its file system */
#define	VTEXT		0x0002	/* vnode is a pure text prototype */
	/* VSYSTEM only used to skip vflush()ing quota files */
#define	VSYSTEM		0x0004	/* vnode being used by kernel */
	/* VISTTY used when reading dead vnodes */
#define	VISTTY		0x0008	/* vnode represents a tty */
#define	VEXECMAP	0x0010	/* vnode has PROT_EXEC mappings */
#define VLOCKSWORK  0x0080  /* FS supports locking discipline */
#define	VXLOCK		0x0100	/* vnode is locked to change underlying type */
#define	VXWANT		0x0200	/* process is waiting for vnode */
#define	VBWAIT		0x0400	/* waiting for output to complete */
#define	VALIASED	0x0800	/* vnode has an alias */
#define	VDIROP		0x1000	/* LFS: vnode is involved in a directory op */
#define	VLAYER		0x2000	/* vnode is on a layer filesystem */
#define	VONWORKLST	0x4000	/* On syncer work-list */
#define	VDIRTY		0x8000	/* vnode possibly has dirty pages */

/*
 *  Modes.  Passed in VnodeOpCheckAccess
 */
#define	VREAD	00004		/* read, write, execute permissions */
#define	VWRITE	00002
#define	VEXEC	00001

/*
 * Flags to various vnode operations.
 */
#define	REVOKEALL		0x0001		/* revoke: revoke all aliases */

#define	FSYNC_WAIT		0x0001		/* fsync: wait for completion */
#define	FSYNC_DATAONLY	0x0002		/* fsync: hint: sync file data only */
#define	FSYNC_RECLAIM	0x0004		/* fsync: hint: vnode is being reclaimed */
#define	FSYNC_LAZY		0x0008		/* fsync: lazy sync (trickle) */

#define	UPDATE_WAIT		0x0001		/* update: wait for completion */
#define	UPDATE_DIROP	0x0002		/* update: hint to fs to wait or not */
#define UPDATE_CLOSE    0x0004      /* update: clean up on close */

#define	IO_UNIT			0x01		/* do I/O as atomic unit */
#define	IO_APPEND		0x02		/* append write to end */
#define	IO_SYNC			(0x04|IO_DSYNC)	/* sync I/O file integrity completion */
#define	IO_NODELOCKED	0x08		/* underlying node already locked */
#define	IO_NDELAY		0x10		/* FNDELAY flag set in file table */
#define	IO_DSYNC		0x20		/* sync I/O data integrity completion */
#define	IO_ALTSEMANTICS	0x40		/* use alternate i/o semantics */

// declares a struct type buflists
LIST_HEAD(BufferCacheList, BufferCacheEntryType);

typedef struct VnodeType {
	uint32_t   v_numBuffers; // number of buffers in the cleanList + dirtyList
	uint32_t   v_refCount;  // number of references to this vnode
	void      *v_mount;  // ptr to file system vnode belongs to
	struct BufferCacheList v_cleanListHead; // head of list of clean buffers that belong to this vnode
	struct BufferCacheList v_dirtyListHead; // head of list of dirty buffers that belong to this vnode
	LIST_ENTRY(VnodeType) v_dirtyList; // this field allows linking vnodes w/ dirty buffers
	LIST_ENTRY(VnodeType) v_mountList; // this field allows linking vnodes in a mount
	uint8_t    v_type; // vnode type, used internally by VFS filesystems
	uint8_t    v_tag;  // vnode tag type, used to report type externally
	uint16_t   v_flag; // flags
	union {					 /* made this a union to make it easier to debug,
								filesystems will use the InodeType field */
		void *data;
		struct InodeType *inodeP;
	} v_union;                // private data specific to filesystem

#define v_data v_union.data
#define v_inodeP v_union.inodeP
	const vnode_ops *v_op;   // pointer to filesystem specific operations vector
} VnodeType;


#include <support/errors.h>

__inline status_t VnodeInvokeOpReadBuffers(VnodeType *vnode, size_t count, BufferCacheEntryType **bufCacheP)
{
	// equivalent to BSD VOP_STRATEGY
	if (vnode->v_op->readbuffers) {
		return vnode->v_op->readbuffers(vnode, count, bufCacheP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpWriteBuffers(VnodeType *vnode, size_t count, BufferCacheEntryType **bufCacheP)
{
	if (vnode->v_op->writebuffers) {
		return vnode->v_op->writebuffers(vnode, count, bufCacheP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpReclaim(VnodeType *vnode)
{
	if (vnode->v_op->reclaim) {
		return vnode->v_op->reclaim(vnode);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpLookup(VnodeType *dirVnodeP, VnodeType **resultVnodePP, struct componentname *cnp)
{
	if (dirVnodeP->v_op->lookup) {
		return dirVnodeP->v_op->lookup(dirVnodeP, resultVnodePP, cnp);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpGetBufferForOffset(VnodeType *dirVnodeP, off_t offset, BufferCacheEntryType **bufCachePP)
{
	if (dirVnodeP->v_op->getbufferforoffset) {
		return dirVnodeP->v_op->getbufferforoffset(dirVnodeP, offset, bufCachePP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpBufferAllocate(VnodeType *vnodeP, off_t offset, int32_t size, uint32_t flags, BufferCacheEntryType **bufCachePP)
{
	if (vnodeP->v_op->bufferallocate) {
		return vnodeP->v_op->bufferallocate(vnodeP, offset, size, flags, bufCachePP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpCreate(VnodeType *dirVnodeP, VnodeType **resultVnodePP, struct componentname *cnp)
{
	if (dirVnodeP->v_op->create) {
		return dirVnodeP->v_op->create(dirVnodeP, resultVnodePP, cnp);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpAllocateVnode(VnodeType *parentVnodeP, VnodeType **resultVnodePP)
{
	if (parentVnodeP->v_op->allocate_vnode) {
		return parentVnodeP->v_op->allocate_vnode(parentVnodeP, resultVnodePP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpWriteVnode(VnodeType *vnodeP, char flags)
{
	if (vnodeP->v_op->write_vnode) {
		return vnodeP->v_op->write_vnode(vnodeP, flags);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpTruncate(VnodeType *vnodeP, off_t endOffset, uint32_t flags)
{
	if (vnodeP->v_op->truncate) {
		return vnodeP->v_op->truncate(vnodeP, endOffset, flags);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpOpenVnode(VnodeType *vnodeP, int omode)
{
	if (vnodeP->v_op->open) {
		return vnodeP->v_op->open(vnodeP, omode);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpMakeDirectory(VnodeType *parentDirVnodeP, VnodeType **newDirVnodePP, struct componentname *cnp)
{
	if (parentDirVnodeP->v_op->mkdir) {
		return parentDirVnodeP->v_op->mkdir(parentDirVnodeP, newDirVnodePP, cnp);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpGetPhysicalBlockAddress(VnodeType *vnodeP, lbno_t logicalBlockNum, bno_t *physicalBlockNumP, int *numP)
{
	if (vnodeP->v_op->getphysicalblockaddr) {
		return vnodeP->v_op->getphysicalblockaddr(vnodeP, logicalBlockNum, physicalBlockNumP, numP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpWrite(VnodeType *vnodeP, off_t offset, const uint8_t *dataP, size_t *numBytesP)
{
	if (vnodeP->v_op->write) {
		return vnodeP->v_op->write(vnodeP, offset, dataP, numBytesP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpRead(VnodeType *vnodeP, off_t offset, uint8_t *dataP, size_t *numBytesP)
{
	if (vnodeP->v_op->read) {
		return vnodeP->v_op->read(vnodeP, offset, dataP, numBytesP);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpUnlink(struct VnodeType *parentDirVnodeP, VnodeType *vnodeP, struct componentname *cnp)
{
	if (vnodeP->v_op->unlink) {
		return vnodeP->v_op->unlink(parentDirVnodeP, vnodeP, cnp);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpRmdir(struct VnodeType *parentDirVnodeP, VnodeType *vnodeP, struct componentname *cnp)
{
	if (vnodeP->v_op->rmdir) {
		return vnodeP->v_op->rmdir(parentDirVnodeP, vnodeP, cnp);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpRename(struct VnodeType *oldDirVnodeP, struct VnodeType *oldVnodeP, struct componentname *oldcnp, 
									  struct VnodeType *newDirVnodeP, struct VnodeType *newVnodeP, struct componentname *newcnp)
{
	if (oldDirVnodeP->v_op->rename) {
		return oldDirVnodeP->v_op->rename(oldDirVnodeP, oldVnodeP, oldcnp, newDirVnodeP, newVnodeP, newcnp);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpCheckAccess(struct VnodeType *vnodeP, int mode, uint32_t callerID)
{
	if (vnodeP->v_op->check_access) {
		return vnodeP->v_op->check_access(vnodeP, mode, callerID);
	}
	return B_UNSUPPORTED;
}

__inline status_t VnodeInvokeOpUpdate(struct VnodeType *vnodeP, time_t accessTime, time_t modifyTime, int flags)
{
	if (vnodeP->v_op->update) {
		return vnodeP->v_op->update(vnodeP, accessTime, modifyTime, flags);
	}
	return B_UNSUPPORTED;
}

__inline void VnodeIncrementReference(VnodeType *vnode)
{
	vnode->v_refCount++;
}

#if 0
__inline status_t VnodeWriteBuffers(VnodeType *vnode, ssize_t count, BufferCacheEntryType **bufCacheP)
{
	if (vnode->v_op->writebuffers) {
		return vnode->v_op->writebuffers(vnode, count, bufCacheP);
	}
	return B_UNSUPPORTED;
}
#endif


#ifdef __cplusplus
}
#endif
  

#endif /* #ifndef _VNODE_H_ */
