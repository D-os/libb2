/*
 * Copyright (c) 2005 Palmsource, Inc.
 *
 * This software is licensed as described in the file LICENSE, which
 * you should have received as part of this distribution. The terms
 * are also available at http://www.openbinder.org/license.html.
 *
 * This software consists of voluntary contributions made by many
 * individuals. For the exact contribution history, see the revision
 * history and logs, available at http://www.openbinder.org
 */

#ifndef SUPPORT_IMEMORY_H
#define SUPPORT_IMEMORY_H

/*!	@file support/IMemory.h
	@ingroup CoreSupportBinder
	@brief Binder-based shared memory interfaces.
*/

#include <support/Atom.h>
#include <support/Binder.h>
#include <support/IInterface.h>
#include <support/Parcel.h>
#include <support/Value.h>

namespace os {
namespace support {

/*!	@addtogroup CoreSupportBinder
	@{
*/

//////////////////////////////////////////////////////////////////
// IMemoryHeap Interface
//////////////////////////////////////////////////////////////////

//!	Handle on a shared memory heap.
/*!	This object represents the full shared memory heap that an
	IMemory exists in.  You will not normally need it, instead
	using the IMemory::Pointer() and IMemory::Size() methods to
	retrieve the actual location of an IMemory.

	@note This is a custom interface, it is not generated by
	pidgen.
*/
class IMemoryHeap : public IInterface
{
 public:
  DECLARE_META_INTERFACE(MemoryHeap)

  /*! Returns the area_id (Linux shim) of this heap */
  virtual int32_t HeapID() const = 0;
  /*! Returns the mapped base address (Linux shim) of this heap */
  virtual void *HeapBase() const = 0;
};

//////////////////////////////////////////////////////////////////
// IMemory Interface
//////////////////////////////////////////////////////////////////

//!	Handle on a shared memory region.
/*!	This object represents an allocation in a shared memory
	heap.  The memory allocation it represents will not be
	deallocated until all references on this object (in all
	processes) have gone away.  You do not explicitly free
	the memory yourself.

	This object can be passed across processes, in which case access
	to the entire heap is transfered to the destination process.

	@note This is a custom interface, it is not generated by
	pidgen.
*/
class IMemory : public IInterface
{
 public:
  DECLARE_META_INTERFACE(Memory)

  //!	Get the IMemoryHeap and offset into it of that block of memory.
  virtual sptr<IMemoryHeap> GetMemory(ssize_t *offset = NULL, ssize_t *size = NULL) const = 0;

  //!	A convenience to retrieve the memory pointer from a given IMemory.
  void *Pointer() const;

  //!	Retrieve memory address when you know the heap it exists in and offset there-in.
  void *FastPointer(const sptr<IBinder> &heap, ssize_t offset) const;

  //!	Retrieve the memory size.
  ssize_t Size() const;
};

//////////////////////////////////////////////////////////////////
// IMemoryDealer Interface
//////////////////////////////////////////////////////////////////

//!	Interface to a service that can perform shared memory allocations.
/*!	The single API, Allocate(), performs in allocation a shared
	memory heap and returns an IMemory handle to that allocation,
	and transfers access to the shared memory back to the calling
	process.

	There is no explicit API to free the memory.  Instead, it will
	be freed automatically when all references to the returned
	IMemory object go away and the object is destroyed.

	@note This is a custom interface, it is not generated by
	pidgen.
*/
class IMemoryDealer : public IInterface
{
 public:
  DECLARE_META_INTERFACE(MemoryDealer)

  //!	Allocates shared memory and returns an IMemory.
  virtual sptr<IMemory> Allocate(size_t size, uint32_t properties) = 0;
};

/*!	@} */

//////////////////////////////////////////////////////////////////

class BnMemoryHeap : public BnInterface<IMemoryHeap>
{
 protected:
  inline BnMemoryHeap() : BnInterface<IMemoryHeap>() {}
  inline virtual ~BnMemoryHeap() {}
  virtual status_t HandleEffect(const SValue &in,
                                const SValue &inBindings,
                                const SValue &outBindings,
                                SValue *      out);
  virtual status_t Transact(uint32_t code,
                            SParcel &data,
                            SParcel *reply = NULL,
                            uint32_t flags = 0);

 private:
  BnMemoryHeap(const BnMemoryHeap &);
  BnMemoryHeap &operator=(const BnMemoryHeap &);
};

class BnMemory : public BnInterface<IMemory>
{
 protected:
  inline BnMemory() : BnInterface<IMemory>() {}
  inline virtual ~BnMemory() {}
  virtual status_t HandleEffect(const SValue &in,
                                const SValue &inBindings,
                                const SValue &outBindings,
                                SValue *      out);
  virtual status_t Transact(uint32_t code,
                            SParcel &data,
                            SParcel *reply = NULL,
                            uint32_t flags = 0);

 private:
  BnMemory(const BnMemory &);
  BnMemory &operator=(const BnMemory &);
};

class BnMemoryDealer : public BnInterface<IMemoryDealer>
{
 protected:
  inline BnMemoryDealer() : BnInterface<IMemoryDealer>() {}
  inline virtual ~BnMemoryDealer() {}
  virtual status_t HandleEffect(const SValue &in,
                                const SValue &inBindings,
                                const SValue &outBindings,
                                SValue *      out);
  virtual status_t Transact(uint32_t code,
                            SParcel &data,
                            SParcel *reply = NULL,
                            uint32_t flags = 0);

 private:
  BnMemoryDealer(const BnMemoryDealer &);
  BnMemoryDealer &operator=(const BnMemoryDealer &);
};

}  // namespace support
}  // namespace os

#endif /* SUPPORT_IMEMORY_H */
